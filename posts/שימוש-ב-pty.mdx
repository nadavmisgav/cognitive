---
title: שימוש בpty
category: לינוקס
createdAt: 31.08.2023
description: כבר כמה זמן שאני לא מרגיש שאני מבין טוב מה זה tty וpty. השתמשתי בpty כדי לייצר remote shell אשר עובד ומרגיש ממש כמו shell רגיל ובנוסף עשיתי שינוי קטן על מנת שתמיד שאני מקליד הכל יוקלד פעמיים. TODO
image: https://images.unsplash.com/photo-1530686350401-7de25243dd89?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=2071&q=80

---

## הקדמה

תמיד אהבתי בתוכנה שדברים נראים טוב, שבסוף יש למשתמש
UI
ממש נוח ויפה. כנראה זה גם מה שגרם לי מאד להימשך לפיתוח אתרים ולראייה זה האתר בלוגים השלישי שכתבתי כבר שמתבסס על עיצוב ישן יחסית שלי לאיך אני מדמיין בלוג פשוט.
לא רק אתרים אלא גם תמיד אהבתי
שהvim
שלי סופר מקונפג ונראה טוב וגם
הshell
שעבדתי איתו.
פעם ראשונה שכתבתי
בC
reverse shell
זה באמת היה נראה לי דיי פשוט אפילו אפשר באמצעות
netcat
לעשות את זה בשורה אתת

```bash
nc -l 12345 -e /bin/bash
```

אבל מתקבל
UX
דיי מעפן, גם נראה חרא וגם הרבה פונקציונליות מוכרת לא עובדת (ללחוץ למעלה,
`Ctrl+C`
ועוד).

![nc reverse shell](../nc-reverse-shell.gif "nc reverse shell")


בפעם אחרת שרציתי לכתוב
shell
אינטרקטיבי זה היה
בpython
ושם החוויה הייתה הרבה יותר טובה,
השתממשתי בספריה מגניבה שנקראית
`cli`
היא מפשטת את רוב העבודה של
הshell
עצמו ונותנת לך להתעסק רק בלוגיקה של הפקודות שלך ואפילו מאפשרת לך דברים כמו השלמה אוטומטית עם
`TAB`.
בהמשך בכל מיני פרויקטים נתקלתי
בshell
שרציתי שיעבוד בצורה מסויומת וזה גרם לי להבין שאין לי מושג איך זה עובד מאחורי הקלעים.


## TTY



## כתיבת reverse shell
אוקיי עכשיו שאנחנו קצת יותר מבינים איך כל זה עובד ולמה בכלל יש דבר כזה שנקרא
pty
רציתי לנסות לבנות
reverse shell
משלי. יש את השלב של לכתוב שרת 
TCP
בסיסי
בC,
זה קיים בקוד המלא שאצרף בסוף אבל זו משימה לא מורכבת.
אחרי שכתבתי שרת בעיקרון יש לי
fd
שמייצג
socket
עבור מי שהתחבר לשרת.
אם נרצה לשחזר את השרת
netcat
ממקודם זה תכלס דיי פשוט וזה דורש רק לעשות
`dup`
של
הfd
לstdin, stdout וstderr
ואז להריץ לדוגמה bash.
```c
dup2(client_fd, STDIN_FILENO);
dup2(client_fd, STDOUT_FILENO);
dup2(client_fd, STDERR_FILENO);
execl("/bin/bash", "/bin/bash", NULL);
```
אבל שוב חסר לו מלא פיצרים שאנחנו רגילים אליהם
בshell.
כדי להתגבר על זה נספק
לbash
מה שהוא באמת מצפה לו שזה לא
socket
אלא
tty
או במקרה שלנו
בuserspace
זה יהיה פשוט לייצר לו
pty
משלו שיוכל לשלוט עליו. הקריאה ליצירת
pty
היא
`openpty`
אם עושים
`man`
על הפקודה רואים שיש עוד כמה פקודות שקשורות
לpty
אך בשלב הזה הן לא ככ עניינו אותי
(ספוילר: טעות!!).
עכשיו שיצרתי
pty
הקוד שאני חשבתי שיספיק כדי לייצר את הלוגיקה שמעניינת אותי נראה בערך ככה

```c
openpty(&amaster, &aslave, NULL, NULL, NULL);
pid = fork()
if (0 == pid) { // child
    dup2(aslave, STDIN_FILENO);
    dup2(aslave, STDOUT_FILENO);
    dup2(aslave, STDERR_FILENO);
    execl("/bin/bash", "/bin/bash", NULL);
}

// parent
dup2(amaster, client_fd);
wait(&wstatus);
```

המחשבה שלי הייתה שאני אצור את
הpty
ואת החלק של
הslave,
שהוא אשכרה מדמה
pty,
אעביר
לbash.
לגבי החלק של
הmaster
לא הייתי בטוח ככ אבל הגיון שלי אמר, נקשר אותו פשוט חזרה למי שהתחבר אליי,
ככה כל דבר
מהbash
יעבור דרך
הslave
לmaster
ומשם
לsocket,
ולהפך.

## client
בהתחלה חשבתי לממש בעצמי גם את הצד של הלקוח, אבל גם שם מאד הסתבכתי משתי סיבות,
1. בדומה לשרת לא היה לי ברור מה הלוקיגה המרכזית שאמורה לרוץ, האם פשוט אני עושה dup לstdin, stdout וstderr לsocket שלו ? כי אם עשיתי רק את זה אז הקוד יצר יצא, שזה דיי הגיוני כי כלום לא קורה. הייתי צריך ליצור משהו שכל הזמן יחכו לinput ויעביר אותו לsocket וכל הזמן יקשיב למה קורה בsocket ויעביר לstdout.
2. גם שהוספתי את הלוקיגה של להעביר בין השרת ללקוח מהבעיה שתיארתי קודם, שמתי לב שדברים נכתבים לי פעמיים ואם אני לוחץ למעלה או `Ctrl+C` זה משבש הכל וסוגר את התוכנה בהתאמה. בדומה מאד לשרת netcat ממקודם.

פה בעצם נכנס פעם שנייה ההבנה, שגם בצד לקוח אני גם צריך לעשות איזה שהוא שינוי
בtty
שהוא עובד איתו כי בעצם אני מבין שפקודות כמו
`Ctrl+C`
או אפילו כל אות שאני מקליד לא מנוהלות על ידי התוכנה שלי אלא על ידי
הtty driver.
ניסוי קטן שעשיתי כדי להבין את הקטע שהכל מנוהל על ידי
הtty
זה לשנות את
הtty driver
בקרנל כדי שיכתוב פעמיים כל אות שאני כותב על ידי הוספת קריאת
write
נוספת על מה שהייתה כבר.

```diff
--- a/drivers/tty/tty_io.c
+++ b/drivers/tty/tty_io.c
@@ -1025,6 +1025,9 @@ static inline ssize_t do_tty_write(
                if (ret <= 0)
                        break;
 
+               ret = write(tty, file, tty->write_buf, size);
+               if (ret <= 0) break;
+
                written += ret;
```

ובאמת עכשיו הכל מופיע פעמיים, כלומר אני מבין שהרבה דברים שחשבתי
שהshell
שלי מטפל בהם הם בכלל בקרנל דרך
הtty.
אז חזרה מהניסוי, תכלס יש שני פיצרים שקשורים ל
tty
שאני צריך לעשות בצד של הלקוח על מנת שיעבוד עם
shell
מהשרת.

1. לכבות בtty את הפיצר שעושה echo חזרה לכל דבר שאני מקליד, ולתת פשוט לpty בצד שרת לנהל את זה.
2. להפעיל מצב raw, שלמעשה אומר לtty לא לטפל בשום קלט מיוחד כמו `Ctrl+C` וככה אני פשוט אעביר אותו כמו שהוא לשרת והוא יטפל בו.

עכשיו אפשר לעשות את כל זה עם בינאריים קיימים ולא היה לי עניין מיוחד להבין מעבר למה שהבנתי את הצד לקוח אז מעכשיו פשוט אשתמש
בsocat.

```bash
socat STDIN,echo=0,raw tcp-connect:127.0.0.1:8000
```

## חזרה לשרת
העבודה על הלקוח גרמה לי להבין שגם בצד שרת הנחתי שדברים יותר מידי עובדים בקסם,
למעשה הבנתי
שהdup
שעשיתי בין
הmaster
לsocket
היה מאד אופטימי ובאמת שניסיתי רק אותו אז ישר אחרי שהלקוח יתחבר השרת היה מתנתק כי למעשה נגמרה הלוקיגה. אני בפועל צריך קוד שבאמת יבצע העתקה בין כל דבר שמגיע
מהsocket
לmaster
ולהפך,
כי אחרת אין לוגיקה שבאמת מסתכל על המידע שיש בשני
הfdים
האלו.
אז כתבתי קוד דיי גנרי שעושה את זה שנראה בערך ככה,
```c
int swap(int fd1, int fd2) {
  for(;;) {
    select(...);

    if (FD_ISSET(fd1, &fds)) {
      num_bytes_read = read(fd1, buf, MAXBUF);
      write(fd2, buf, num_bytes_read);
    } else if (FD_ISSET(fd2, &fds)) {
      num_bytes_read = read(fd2, buf, MAXBUF);
      write(fd1, buf, num_bytes_read);
    }
  }
}
```

![remote shell](../remote-shell.gif "remote shell")

ואז זה עבד שזה מטורף!! ממש קיבלתי
shell
שנראה ומתנהג כמו
shell
רגיל.
דבר אחד שהיה בעייתי זה
שbash
זרק הודעה שקשורה
לgroup id
שלא ככ הבנתי. מקריאה שוב על הפונקציות השונות שיש
לpty
ראיתי שיש גם
`login_tty`
וגם `forkpty`
ששם מוסבר שבאמת
`login_tty`
עושה פעולה דומה למה שעשיתי ומבצעת את
הdupים 
שאני עשיתי. מקריאה בקוד של
`login_tty`
נראה שהיא עושה גם עוד שתי פעולות שאני לא עשיתי  

```c
int
login_tty (int fd)
{
	(void) setsid();
#ifdef TIOCSCTTY
	if (ioctl(fd, TIOCSCTTY, (char *)NULL) == -1)
		return (-1);
#else
	{
```

הפעולה הראשונה היא 
`setsid`
שמייצרת 
process group 
חדש
שהprocess
הנוכחי הוא היחיד בו, כלומר
session
נקי. אני לא התעמקתי בזה אבל זה כבר סידר את ההערה של
bash 
שכנראה פשוט מצפה שככה זה יהיה שהוא מתחיל.
הפעולה השנייה הייתה לי קצת פחות ברור וזה
`TIOCSCTTY`,
כשקוראים על זה פשוט כתוב שזה הופך את
הterminal
הנוכחי לשולט עבור אותו
session.
זה היה לי מוזר כי תכלס אני דאגתי באמצעות
dupים
שהוא באמת יהיה
הterminal
השולט, ניסיתי להוריד את השורה הזאת וזה עדיין עבד לי אז חיפשתי עוד קצת באינטרנט,
ונתקלתי במישהו שאמר שהוא עשה משהו דומה לשלי אבל במקום
bash
הוא רצה לייצר
session
של
ssh.
אבל הוא שם לב שהקוד של`
ssh
לא מצליח לעשות
prompt
לסיסמה ובאמת אנשים הציעו לו לעשות את זה כדי לתקן את הבעיה שלו, בעצם יש
struct
בקרנל שעוקב אחרי
הsession
וגם אחרי מי 
הterminal
של אותו
session
ולכן אם רוצים התחלה נקייה גם נצטרך לפתוח
session
חדש וגם להצמיד לו את
הpty
שיצרנו
כterminal
שלו.


רק נשאר לנו אז בעצם זה
`forkpty`,
בסוף הבינו שאוסף הפעולות שעשיתי
`openpty`
ואז
`fork`
ואז לבצע שכפול
לfdים
וגם שינוי
הtty
לpty
שיצרנו בprocess
החדש, כל אלו, דיי נפוצות ואיגדו אותם לקריאה אחת שפשוט עושה את הכל ומחזירה לך את
הpid
שנוצר ומביאה לך
fd
שמשוייך
לmaster,
כאשר
הslave
כבר למעשה לא מעניין אותך כי עשו עבורך את כל הפעולות שצריך לעשות איתו.
הקוד אז ניהיה הרבה יותר פשוט ברגע שמשתמשים
ב`forkpty`
אך הרבה מהדברים שלמדתי והבנתי מוחבאים בקריאה הקסומה הזאת. הקוד הסופי נמצא
[פה](https://gist.github.com/nadavmisgav/b744fe8443c077f54cab87fcb3b29e56)
 , לא השקעתי בו הרבה אבל מי שרוצה לראות מהת חלה לסוף את כל הקוד אז שיהיה.




