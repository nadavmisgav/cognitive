---
title: שימוש בpty
category: לינוקס
createdAt: 31.08.2023
description: כבר כמה זמן שאני לא מרגיש שאני מבין טוב מה זה tty וpty. השתמשתי בpty כדי לייצר remote shell אשר עובד ומרגיש ממש כמו shell רגיל ובנוסף עשיתי שינוי קטן על מנת שתמיד שאני מקליד הכל יוקלד פעמיים. TODO
image: https://images.unsplash.com/photo-1530686350401-7de25243dd89?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=2071&q=80

---

## הקדמה

תמיד אהבתי בתוכנה שדברים נראים טוב, שבסוף יש למשתמש
UI
ממש נוח ויפה. כנראה זה גם מה שגרם לי מאד להימשך לפיתוח אתרים ולראייה זה האתר בלוגים השלישי שכתבתי כבר שמתבסס על עיצוב ישן יחסית שלי לאיך אני מדמיין בלוג פשוט.
לא רק אתרים אלא גם תמיד אהבתי
שהvim
שלי סופר מקונפג ונראה טוב וגם
הshell
שעבדתי איתו.
פעם ראשונה שכתבתי
בC
reverse shell
זה באמת היה נראה לי דיי פשוט אפילו אפשר באמצעות
netcat
לעשות את זה בשורה אתת

```bash
nc -l 12345 -e /bin/bash
```

אבל מתקבל
UX
דיי מעפן, גם נראה חרא וגם הרבה פונקציונליות מוכרת לא עובדת (ללחוץ למעלה,
`Ctrl+C`
ועוד).

![nc reverse shell](../nc-reverse-shell.gif "nc reverse shell")


בפעם אחרת שרציתי לכתוב
shell
אינטרקטיבי זה היה
בpython
ושם החוויה הייתה הרבה יותר טובה,
השתממשתי בספריה מגניבה שנקראית
`cli`
היא מפשטת את רוב העבודה של
הshell
עצמו ונותנת לך להתעסק רק בלוגיקה של הפקודות שלך ואפילו מאפשרת לך דברים כמו השלמה אוטומטית עם
`TAB`.
בהמשך בכל מיני פרויקטים נתקלתי
בshell
שרציתי שיעבוד בצורה מסויומת וזה גרם לי להבין שאין לי מושג איך זה עובד מאחורי הקלעים.


## TTY



## כתיבת reverse shell
אוקיי עכשיו שאנחנו קצת יותר מבינים איך כל זה עובד ולמה בכלל יש דבר כזה שנקרא
pty
רציתי לנסות לבנות
reverse shell
משלי. יש את השלב של לכתוב שרת 
TCP
בסיסי
בC,
זה קיים בקוד המלא שאצרף בסוף אבל זו משימה לא מורכבת.
אחרי שכתבתי שרת בעיקרון יש לי
fd
שמייצג
socket
עבור מי שהתחבר לשרת.
אם נרצה לשחזר את השרת
netcat
ממקודם זה תכלס דיי פשוט וזה דורש רק לעשות
`dup`
של
הfd
לstdin, stdout וstderr
ואז להריץ לדוגמה bash.
```c
dup2(client_fd, STDIN_FILENO);
dup2(client_fd, STDOUT_FILENO);
dup2(client_fd, STDERR_FILENO);
execl("/bin/bash", "/bin/bash", NULL);
```
אבל שוב חסר לו מלא פיצרים שאנחנו רגילים אליהם
בshell.
כדי להתגבר על זה נספק
לbash
מה שהוא באמת מצפה לו שזה לא
socket
אלא
tty
או במקרה שלנו
בuserspace
זה יהיה פשוט לייצר לו
pty
משלו שיוכל לשלוט עליו. הקריאה ליצירת
pty
היא
`openpty`
אם עושים
`man`
על הפקודה רואים שיש עוד כמה פקודות שקשורות
לpty
אך בשלב הזה הן לא ככ עניינו אותי
(ספוילר: טעות!!).
עכשיו שיצרתי
pty
הקוד שאני חשבתי שיספיק כדי לייצר את הלוגיקה שמעניינת אותי נראה בערך ככה

```c
openpty(&amaster, &aslave, NULL, NULL, NULL);
pid = fork()
if (0 == pid) { // child
    dup2(aslave, STDIN_FILENO);
    dup2(aslave, STDOUT_FILENO);
    dup2(aslave, STDERR_FILENO);
    execl("/bin/bash", "/bin/bash", NULL);
}

// parent
dup2(amaster, client_fd);
wait(&wstatus);
```

המחשבה שלי הייתה שאני אצור את
הpty
ואת החלק של
הslave,
שהוא אשכרה מדמה
pty,
אעביר
לbash.
לגבי החלק של
הmaster
לא הייתי בטוח ככ אבל הגיון שלי אמר, נקשר אותו פשוט חזרה למי שהתחבר אליי,
ככה כל דבר
מהbash
יעבור דרך
הslave
לmaster
ומשם
לsocket,
ולהפך.

## client
בהתחלה חשבתי לממש בעצמי גם את הצד של הלקוח, אבל גם שם מאד הסתבכתי משתי סיבות,
1. בדומה לשרת לא היה לי ברור מה הלוקיגה המרכזית שאמורה לרוץ, האם פשוט אני עוד dup לstdin, stdout וstderr לsocket שלו ? כי אם עשיתי רק את זה אז הקוד יצר יצא, שזה דיי הגיוני כי כלום לא קורה. הייתי צריך ליצור משהו שכל הזמן יחכו לinput ויעביר אותו לsocket וכל הזמן יקשיב למה קורה בsocket ויעביר לstdout.
2. גם שהוספתי את הלוקיגה של להעביר בין השרת ללקוח מהבעיה שתיארתי קודם, שמתי לב שדברים נכתבים לי פעמיים ואם אני לוחץ למעלה או `Ctrl+C` זה משבש הכל וסוגר את התוכנה בהתאמה.

פה בעצם נכנס פעם שנייה ההבנה, שגם בצד לקוח אני גם צריך לעשות איזה שהוא שינוי
בtty
שהוא עובד איתו כי בעצם אני מבין שפקודות כמו
`Ctrl+C`
או אפילו כל אות שאני מקליד לא מנוהלות על ידי התוכנה שלי אלא על ידי
הtty driver.
ניסוי קטן שעשיתי כדי להבין את הקטע שהכל מנוהל על ידי
הtty
זה לשנות את
הtty driver
בקרנל כדי שיכתוב פעמיים כל אות שאני כותב על ידי הוספת קריאת
write
נוספת על מה שהייתה כבר.

```diff
--- a/drivers/tty/tty_io.c
+++ b/drivers/tty/tty_io.c
@@ -1025,6 +1025,9 @@ static inline ssize_t do_tty_write(
                if (ret <= 0)
                        break;
 
+               ret = write(tty, file, tty->write_buf, size);
+               if (ret <= 0) break;
+
                written += ret;
```

ובאמת עכשיו הכל מופיע פעמיים, כלומר אני מבין שהרבה דברים שחשבתי
שהshell
שלי מטפל בהם הם בכלל בקרנל דרך
הtty.
אז חזרה מהניסוי, תכלס יש שני שינויים שאני צריך לעשות בצד של הלקוח על מנת שיעבוד עם
shell
מהשרת.

1. אני צריך לוגיקה שמקשרת בין stdin וstdout לsocket.
2. אני צריך לכבות בtty של הלקוח שני פיצ'רים. הראשון הוא echo על מנת שלא ידפיס לי כל דבר שאני כותב כי בעצם מי שיהיה אחראי על זה הוא הtty בצד שרת. השני הוא להפעיל מצב raw שזה בעצם אומר לו לא לטפל בשום קלט שלי ואז הקלדות כמו `Ctrl+C` יועברו גם לשרת והוא יטפל בהם על ידי הtty שלו.



