---
title: שימוש בpty
category: לינוקס
createdAt: 31.08.2023
description: כבר כמה זמן שאני לא מרגיש שאני מבין טוב מה זה tty וpty. השתמשתי בpty כדי לייצר remote shell אשר עובד ומרגיש ממש כמו shell רגיל ובנוסף כדי לראות שאני מבין מה עובר דרך הtty driver עשיתי שינוי כך שכל הקלדה שלי תמיד תופיע פעמיים.
image: https://images.unsplash.com/photo-1530686350401-7de25243dd89?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=2071&q=80

---

## הקדמה

תמיד אהבתי בתוכנה שדברים נראים טוב, שבסוף יש למשתמש
UI
ממש נוח ויפה. כנראה זה גם מה שגרם לי מאד להימשך לפיתוח אתרים ולראייה, זה האתר בלוגים השלישי שכתבתי כבר.
לא רק אתרים אלא גם תמיד אהבתי
שהvim
שלי סופר מקונפג ונראה טוב וגם
הshell
שעבדתי איתו.
פעם ראשונה שכתבתי
remote shell
בC
זה באמת היה נראה לי דיי פשוט אפילו אפשר באמצעות
netcat
לעשות את זה בשורה אתת

```bash
nc -l 12345 -e /bin/bash
```

אבל מאד הציק לי שמתקבל
UX
דיי מעפן, גם נראה חרא וגם הרבה פונקציונליות מוכרת לא עובדת (ללחוץ למעלה,
`Ctrl+C`
ועוד).

![nc reverse shell](../nc-reverse-shell.gif "nc reverse shell")


בפעם אחרת שרציתי לכתוב
shell
אינטרקטיבי זה היה
בpython
ושם החוויה הייתה הרבה יותר טובה.
השתמשתי בספריה מגניבה שנקראת
`cli`
והיא מפשטת את רוב העבודה של
הshell
עצמו ונותנת לך להתעסק רק בלוגיקה של הפקודות שלך ואפילו מאפשרת לך דברים כמו השלמה אוטומטית עם
`TAB` 🤯.
בהמשך בכל מיני פרויקטים נתקלתי
בshell
שרציתי שיעבוד בצורה מסוימת וזה גרם לי להבין שאין לי מושג איך זה עובד מאחורי הקלעים.


## TTY
קונספט דיי היסטורי אבל ממשיך ללוות אותנו גם במערכות הפעלה מודרניות, הקיצור
tty
הוא של
teletypewriter.
אותה מכונה ישנה, שמופיעה כתמונה של פוסט זה, אשר פעם הייתה הבסיס למחשבים. למעשה היא שימשה
את הצורה הכי בסיסית של קלט ופלט. משתמש היה כותב פקודה למחשב, והוא היה רואה את הפקודה שהקליד על חתיכת נייר שעליה היא הודפסה
והמחשב בתורו היה מקליד את הפלט חזרה על דף הנייר.
הtty
היה מחובר למחשב והמחשב היה אחראי לכל מיני פעולות כמו להדפיס לך חזרה מה שכתבת ולרדת שורה שהיה צריך.

כלומר
הtty
היה אחראי על כל חלק הממשק מול המשתמש וגם לאחסן
בbuffer
את כל מה שהמשתמש כתב ואז להעביר את זה לתוכנה כמו
shell
שהיא הייתה למעשה 
התוכנה שטיפלה בפקודות שלו והחזירה את הפלט שלה
לtty.
עם השנים לא היה צריך מכשיר שלם כדי לייצר את הממשק של
הtty
וזה פשוט הפך לחלק
מהkernel.
ברוב ההפצות המוכרות של לינוקס היום ניתן לגשת ל7
ttyים
שונים על ידי לחיצה על
`Ctrl+Alt+F1`
כאשר כל מספר מתייחס
לtty
אחר ובדרך כלל ב7 יהיה
הGUI.
המונח
tty
וterminal
בשלב הזה הפכו כבר לאותה משמעות כאשר שניהם מתייחסים לתוכנה שאחראית על אותו קונספט ישן שהיה פעם של קבלת קלט פלט והצגתו למשתמש ולא השתנה כל השנים הללו.

להרבה שימושים כמו שנראה גם תוכנות
בuserspace
היו רוצות את הפונקציונליות
של
tty
ובשביל שלא כולם יהיו
בkernel
יצרו
pseudoterminal
או בקיצור
pty.
התפקיד שלו זה מצד אחד לתת לתוכנה ממשק שעובר דרך
הtty
שממומש בקרנל ומהצד שני לתת
fd
נוסף שיוכל לתקשר עם אותו
tty
ולקבל ממנו את המידע שלו על מנת לשלוט בהתנהגות הסופית, וזה נראה בצורה מופשטת כך.

![pty diagram](../pty-diagram.png "pty diagram")

## כתיבת remote shell
אוקיי עכשיו שאנחנו קצת יותר מבינים איך כל זה עובד ולמה בכלל יש דבר כזה שנקרא
pty
רציתי לנסות לבנות
remote shell
משלי, שאני אומר
remote shell
דמיינו תוכנה דיי דומה
לssh
. יש את השלב של לכתוב שרת 
TCP
בסיסי
בC,
זה קיים בקוד המלא שאצרף בסוף אבל זו משימה לא מורכבת.
אחרי שכתבתי שרת בעיקרון יש לי
fd
שמייצג
socket
עבור מי שהתחבר לשרת.
אם נרצה לשחזר את השרת
netcat
ממקודם זה תכלס דיי פשוט וזה דורש רק לעשות
`dup`
של
הfd
לstdin, stdout וstderr
ואז להריץ לדוגמה bash.
```c
dup2(client_fd, STDIN_FILENO);
dup2(client_fd, STDOUT_FILENO);
dup2(client_fd, STDERR_FILENO);
execl("/bin/bash", "/bin/bash", NULL);
```
אבל שוב חסר לו מלא פיצ'רים שאנחנו רגילים אליהם
בshell.
כדי להתגבר על זה נספק
לbash
מה שהוא באמת מצפה לו שזה לא
socket
אלא
tty
או במקרה שלנו
בuserspace
זה יהיה פשוט לייצר לו
pty
משלו שיוכל לשלוט עליו. הקריאה ליצירת
pty
היא
`openpty`
אם עושים
`man`
על הפקודה רואים שיש עוד כמה פקודות שקשורות
לpty
אך בשלב הזה הן לא כל כך עניינו אותי
(ספוילר: טעות).
אחרי שיצרתי
pty
הקוד שאני חשבתי שיספיק כדי לייצר את הלוגיקה שמעניינת אותי נראה בערך ככה

```c
openpty(&amaster, &aslave, NULL, NULL, NULL);
pid = fork()
if (0 == pid) { // child
    dup2(aslave, STDIN_FILENO);
    dup2(aslave, STDOUT_FILENO);
    dup2(aslave, STDERR_FILENO);
    execl("/bin/bash", "/bin/bash", NULL);
}

// parent
dup2(amaster, client_fd);
wait(&wstatus);
```

המחשבה שלי הייתה שאני אצור את
הpty
ואת החלק של
הslave,
שהוא אשכרה מדמה
pty,
אעביר
לbash.
לגבי החלק של
הmaster
לא הייתי בטוח כל כך אבל הגיון שלי אמר, נקשר אותו פשוט חזרה למי שהתחבר אליי,
ככה כל דבר
מהbash
יעבור דרך
הslave
לmaster
ומשם
לsocket,
ולהפך. אז המשכתי לעבור לצד לקוח כדי לבדוק את הקוד שלי.

## client
בהתחלה חשבתי לממש בעצמי גם את הצד של הלקוח, אבל גם שם מאד הסתבכתי משתי סיבות,
1. בדומה לשרת לא היה לי ברור מה הלוגיקה המרכזית שאמורה לרוץ, האם פשוט אני עושה dup לstdin, stdout וstderr לsocket שלו ? כי אם עשיתי רק את זה אז הקוד ישר סיים את הריצה שלו, שזה דיי הגיוני כי כלום לא קורה. הייתי צריך ליצור משהו שכל הזמן יחכה לinput ויעביר אותו לsocket וכל הזמן יקשיב למה קורה בsocket ויעביר לstdout.
2. גם שהוספתי את הלוגיקה של להעביר בין השרת ללקוח מהבעיה שתיארתי קודם, שמתי לב שדברים נכתבים לי פעמיים ואם אני לוחץ למעלה או `Ctrl+C` זה משבש הכל וסוגר את התוכנה בהתאמה. בדומה מאד לשרת netcat ממקודם שאזכיר, אנחנו לא אוהבים.

פה בעצם נכנס פעם שנייה ההבנה, שגם בצד לקוח אני צריך לעשות איזה שהוא שינוי
בtty
שהוא עובד איתו כי בעצם אני מבין שפקודות כמו
`Ctrl+C`
או אפילו כל אות שאני מקליד לא מנוהלות על ידי התוכנה שלי אלא על ידי
הtty driver.
ניסוי קטן שעשיתי כדי להבין את הקטע שהכל מנוהל על ידי
הtty
זה לשנות את
הtty driver
בקרנל כדי שיכתוב פעמיים כל אות שאני כותב על ידי הוספת קריאת
write
נוספת על מה שהייתה כבר.

```diff
--- a/drivers/tty/tty_io.c
+++ b/drivers/tty/tty_io.c
@@ -1025,6 +1025,9 @@ static inline ssize_t do_tty_write(
                if (ret <= 0)
                        break;
 
+               ret = write(tty, file, tty->write_buf, size);
+               if (ret <= 0) break;
+
                written += ret;
```

ובאמת אחרי השינוי הכל מופיע פעמיים, כל הקלדה שלי וכל הדפסה של תוכנה. אני מבין שהרבה דברים שחשבתי
שהshell
שלי מטפל בהם הם בכלל בקרנל דרך
הtty.
אז חזרה מהניסוי, תכלס יש שני פיצ'רים שקשורים
לtty
שאני צריך לעשות בצד של הלקוח על מנת שיעבוד עם
shell
מהשרת.

1. לכבות בtty את הפיצ'ר שעושה echo חזרה לכל דבר שאני מקליד, ולתת פשוט לpty בצד שרת לנהל את זה.
2. להפעיל מצב raw, שלמעשה אומר לtty לא לטפל בשום קלט מיוחד כמו `Ctrl+C` וככה אני פשוט אעביר אותו כמו שהוא לשרת והוא יטפל בו.

את כל זה אפשר גם לעשות עם בינאריים קיימים ולא היה לי עניין מיוחד להבין מעבר למה שהבנתי את הצד לקוח אז מעכשיו פשוט אשתמש
בsocat.

```bash
socat STDIN,echo=0,raw tcp-connect:127.0.0.1:8000
```

## חזרה לשרת
העבודה על הלקוח גרמה לי להבין שגם בצד שרת הנחתי שדברים יותר מידי עובדים בקסם,
למעשה הבנתי
שהdup
שעשיתי בין
הmaster
לsocket
היה מאד אופטימי. שניסיתי רק אותו אז ישר אחרי שהלקוח התחבר השרת היה מתנתק כי למעשה נגמרה הלוגיקה בצד שלו. אני בפועל צריך קוד שבאמת יחכה למידע
מהsocket
ויבצע העתקה בין כל דבר שמגיע
לmaster
ולהפך,
כי אחרת אין לוגיקה שבאמת מסתכלת על המידע שיש בשני
הfdים
האלו.
אז כתבתי קוד דיי גנרי שעושה את זה שנראה בערך ככה,
```c
int swap(int fd1, int fd2) {
  for(;;) {
    select(...);

    if (FD_ISSET(fd1, &fds)) {
      num_bytes_read = read(fd1, buf, MAXBUF);
      write(fd2, buf, num_bytes_read);
    } else if (FD_ISSET(fd2, &fds)) {
      num_bytes_read = read(fd2, buf, MAXBUF);
      write(fd1, buf, num_bytes_read);
    }
  }
}
```


ואז זה עבד שזה מטורף!! ממש קיבלתי
shell
שנראה ומתנהג כמו
shell
רגיל.
דבר אחד שהיה בעייתי זה
שbash
זרק הודעה שקשורה
לgroup id
שלא כל כך הבנתי.

![remote shell](../remote-shell.gif "remote shell")

 מקריאה שוב על הפונקציות השונות שיש
לpty
ראיתי שיש גם
`login_tty`
וגם `forkpty`
ששם מוסבר שבאמת הקריאה
`login_tty`
עושה פעולה דומה למה שעשיתי ומבצעת את
הdupים 
שאני עשיתי. מקריאה בקוד של
`login_tty`
נראה שהיא עושה גם עוד שתי פעולות שאני לא עשיתי.

```c
int
login_tty (int fd)
{
	(void) setsid();
#ifdef TIOCSCTTY
	if (ioctl(fd, TIOCSCTTY, (char *)NULL) == -1)
		return (-1);
#else
	{
```

הפעולה הראשונה היא 
`setsid`
שמייצרת 
process group 
חדש
שהprocess
הנוכחי הוא היחיד בו, כלומר
session
נקי. אני לא התעמקתי בזה אבל זה כבר סידר את ההערה של
bash 
שכנראה פשוט מצפה שככה זה יהיה שהוא מתחיל על מנת שיהיה לו יכולת לשלוט בילדים שנוצרים תחתיו.

הפעולה השנייה הייתה לי קצת פחות ברורה וזה
`TIOCSCTTY`,
כשקוראים על זה פשוט כתוב שזה הופך את
הterminal
הנוכחי "לשולט" עבור אותו
session.
זה היה לי מוזר כי תכלס אני דאגתי באמצעות
dupים
שהוא באמת יהיה
הterminal
השולט, ניסיתי להוריד את השורה הזאת וזה עדיין עבד לי אז חיפשתי עוד קצת באינטרנט,
ונתקלתי במישהו שאמר שהוא עשה משהו דומה לשלי אבל במקום
bash
הוא רצה לייצר
session
של
ssh.
אבל הוא שם לב שהקוד של
ssh
לא מצליח לעשות
prompt
לסיסמה ובאמת אנשים הציעו לו לעשות את זה כדי לתקן את הבעיה שלו. בעצם יש
struct
בקרנל שעוקב אחרי
הsession
וגם אחרי מי 
הterminal
של אותו
session
ולכן אם רוצים התחלה נקייה נצטרך לפתוח
session
חדש וגם להצמיד לו את
הpty
שיצרנו
כterminal
שלו.


רק נשאר לי להבין אז בעצם מה זה
`forkpty`,
בסוף אנשים חכמים הבינו שאוסף הפעולות שעשיתי
`openpty`
ואז
`fork`
ואז לבצע שכפול
לfdים
וגם שינוי
הtty
לpty
שיצרנו בprocess
החדש, כל אלו. דיי נפוצות ואיגדו אותם לקריאה אחת שפשוט עושה את הכל ומחזירה לך את
הpid
שנוצר ומביאה לך
fd
שמשוייך
לmaster,
כאשר
הslave
כבר למעשה לא מעניין אותך כי עשו עבורך את כל הפעולות שצריך לעשות איתו.

 לסיכום הקוד הופך להרבה יותר פשוט ברגע שמשתמשים
ב`forkpty`
אך הרבה מהדברים שלמדתי והבנתי מוחבאים בקריאה הקסומה הזאת. הקוד הסופי נמצא
[פה](https://gist.github.com/nadavmisgav/b744fe8443c077f54cab87fcb3b29e56),
לא השקעתי בו הרבה אבל מי שרוצה לראות מהתחלה לסוף את כל הקוד אז העליתי.




