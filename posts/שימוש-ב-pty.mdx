---
title: שימוש בpty
category: לינוקס
createdAt: 31.08.2023
description: כבר כמה זמן שאני לא מרגיש שאני מבין טוב מה זה tty וpty. השתמשתי בpty כדי לייצר remote shell אשר עובד ומרגיש ממש כמו shell רגיל ובנוסף עשיתי שינוי קטן על מנת שתמיד שאני מקליד הכל יוקלד פעמיים. TODO
image: https://images.unsplash.com/photo-1530686350401-7de25243dd89?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=2071&q=80

---

## הקדמה

תמיד אהבתי בתוכנה שדברים נראים טוב, שבסוף יש למשתמש
UI
ממש נוח ויפה. כנראה זה גם מה שגרם לי מאד להימשך לפיתוח אתרים ולראייה זה האתר בלוגים השלישי שכתבתי כבר שמתבסס על עיצוב ישן יחסית שלי לאיך אני מדמיין בלוג פשוט.
לא רק אתרים אלא גם תמיד אהבתי
שהvim
שלי סופר מקונפג ונראה טוב וגם
הshell
שעבדתי איתו.
פעם ראשונה שכתבתי
בC
reverse shell
זה באמת היה נראה לי דיי פשוט אפילו אפשר באמצעות
netcat
לעשות את זה בשורה אתת

```bash
nc -l 12345 -e /bin/bash
```

אבל מתקבל
UX
דיי מעפן, גם נראה חרא וגם הרבה פונקציונליות מוכרת לא עובדת (ללחוץ למעלה,
`Ctrl+C`
ועוד).

![nc reverse shell](../nc-reverse-shell.gif "nc reverse shell")


בפעם אחרת שרציתי לכתוב
shell
אינטרקטיבי זה היה
בpython
ושם החוויה הייתה הרבה יותר טובה,
השתממשתי בספריה מגניבה שנקראית
`cli`
היא מפשטת את רוב העבודה של
הshell
עצמו ונותנת לך להתעסק רק בלוגיקה של הפקודות שלך ואפילו מאפשרת לך דברים כמו השלמה אוטומטית עם
`TAB`.
בהמשך בכל מיני פרויקטים נתקלתי
בshell
שרציתי שיעבוד בצורה מסויומת וזה גרם לי להבין שאין לי מושג איך זה עובד מאחורי הקלעים.


## TTY



## כתיבת reverse shell
אוקיי עכשיו שאנחנו קצת יותר מבינים איך כל זה עובד ולמה בכלל יש דבר כזה שנקרא
pty
רציתי לנסות לבנות
reverse shell
משלי. יש את השלב של לכתוב שרת 
TCP
בסיסי
בC,
זה קיים בקוד המלא שאצרף בסוף אבל זו משימה לא מורכת מידי.
אחרי שכתבנו שרת בעיקרון יש בידנו
fd
שמייצג
socket
עבור מי שהתחבר אלינו.
אם נרצה לשחזר את השרת
netcat
ממקודם זה תכלס דיי פשוט וזה דורש רק לעשות
`dup`
של
הfd
לstdin, stdout וstderr
ואז להריץ לדוגמה bash.
```c
dup2(client_fd, STDIN_FILENO);
dup2(client_fd, STDOUT_FILENO);
dup2(client_fd, STDERR_FILENO);
execl("/bin/bash", "/bin/bash", NULL);
```
אבל שוב חסר לו מלא פיצרים שאנחנו רגילים אליהם
בshell.
כדי להתגבר על זה נספק
לbash
מה שהוא באמת מצפה לו שזה לא
socket
אלא
tty
או במקרה שלנו
בuserspace
זה יהיה פשוט לייצר לו
pty
משלו שיוכל לשלוט עליו. הקריאה ליצירת
pty
היא
`openpty`
אם עושים
`man`
על הפקודה רואים שיש עוד כמה פקודות שקשורות
לpty
אך בשלב הזה הן לא ככ עניינו אותי
(ספוילר: טעות!!).
עכשיו שיצרתי
pty
הקוד שאני חשבתי שיספיק כדי לייצר את הלוגיקה שמעניינת אותי נראה בערך ככה

```c
openpty(&amaster, &aslave, NULL, NULL, NULL);
pid = fork()
if (0 == pid) { // child
    dup2(aslave, STDIN_FILENO);
    dup2(aslave, STDOUT_FILENO);
    dup2(aslave, STDERR_FILENO);
    execl("/bin/bash", "/bin/bash", NULL);
}

// parent
dup2(amaster, client_fd);
wait(&wstatus);
```

המחשבה שלי הייתה שאני אצור את
הpty
את החלק של
הslave,
שהוא אשכרה מדמה
pty,
אעביר
לbash.
לגבי החלק של
הmaster
לא הייתי בטוח ככ אבל הגיון שלי אמר, נקשר אותו פשוט חזרה למי שהתחבר אליי,
קח כל דבר
מהbash
יעבור דרך
הslave
לmaster
ומשם
לsocket,
ולהפך.

