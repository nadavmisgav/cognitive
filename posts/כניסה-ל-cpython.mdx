---
title: כניסה לCPython
category: פייתון
createdAt: 14.10.2022
description: Lorem
image: https://images.unsplash.com/photo-1649180556628-9ba704115795?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1162&q=80

---

## הקדמה

כבר תקופה שרציתי ללמוד יותר על
CPython,
אך לא מצאתי סיבה או יותר נכוון פרויקט שיגרום לי ללמוד על זה.
לאחרונה היה לי קצת חופש והחלטתי שוב לתת לזה הזדמנות כאשר התחלתי מלהסתכל על באגים שאולי אני אוכל לנסות לתקן, אפשר למצוא רשימה מלאה
[פה](https://bugs.python.org/)
והיו כמה שעניינו אותי.

1. [91105](https://github.com/python/cpython/issues/91105) הוספה של הדפסה אם עברת את `sys.tracebacklimit`.
2. [91026](https://github.com/python/cpython/issues/91026) שגיאה פרסור של `urlparse`.
3. [91078](https://github.com/python/cpython/issues/91078) קריסה של הספריה `tarfile`.

תחילה כולם היו נראים לי יחסית פשוטים אך הבנתי שאין לי הבנה מספיק טובה של הבעיות המתוארות. בנוסף רציתי להתרכז בללמוד
CPython
ולא היה נראה שפתירת הבעיות הללו יעזרו לי ללמוד את זה.


נזכרתי בהצעה שהייתה לי פעם 
לSyntax
נוסף לפייתון. למעשה הרעיון הגיע כאשר נתקלתי בצורך לכתוב קטע קוד בערך כזה,

```python
try
    ...
except SomeException:
    if ignore_exceptions:
        pass
    else:
        raise
```
כלומר רציתי יכולת לבצע התנייה על הכניסה לבלוק של ה
`except`,
שבדוגמה למעלה ההתנייה תלויה במשתנה שנקרא
`ignore_exceptions`
ורק אם ערכו אמת אני רוצה לתפוס את השגיאה.
אני דמיינתי את
הSyntax
החדש ככה,

```python
try
    ...
except SomeException if ignore_exceptions:
    pass
```

בהתחלה המחשבה שלי הייתה שאם זה נראה כמו קוד סוטה כנראה הלוגיקה שלי פה לא נכונה ויש דרך יותר הגיונית לעשות את זה,
אז הלכתי לחפש בספריות אחרות של פייתון האם יש להם קטע קוד דומה (על איך עושים את זה אולי אכתוב פעם אחרת).
מצאתי לא מעט דוגמאות מאד דומות לשלי והחלטתי לכתוב
לmailing list
שנקרא
python-ideas
לראות אם יש הגיון בהצעה הזאת.
ניתן לראות את השרשור
[פה](https://mail.python.org/archives/list/python-ideas@python.org/thread/XHT2JH5PCS73YC2PIX27MJSZY6XVE53V/#YH7A4GDAJYPG7EIRBCO5U2ESZ2IVYGUE).


אנשים נחמדים ענו לי ואחד הדגים לי שאפשר כבר בערך לעשות את מה שאני רוצה באופן הבא,
```python
try
    ...
except SomeException if ignore_exceptions else ():
    pass
```
בהתחלה לא היה לי ברור כל כך מה אני רואה פה (כמו שאפשר לראות בשרשור המביך יחסית את התלהבות שלי),
אבל אז הבנתי שלמעשה יש פה אופרטור
ternary if.
כלומר אם התנאי מתקיים אז השגיאה שנצפה לה תיהיה 
`SomeException`
אך אם התנאי לא מתקיים אז נצפה 
לtuple
ריק שזה שקול בפייתון ללא לתפוס כלום.
אפשר להבין את הקוד יותר טוב בכתיבה הבאה,

```python
exception_to_except = SomeException if ignore_exceptions else ()
try:
    ...
except exception_to_except:
    pass
```
תכלס, סייבר. אבל זה כתיבה די דוחה כי קשה להבין מה קורה פה וגם אתה חייב את
הelse
המוזר הזה. הערה טובה שמישהו ציין בשרשור זה
שבSyntax
החדש יהיה אפשר לעשות תנאי שתלוי גם בשגיאה שנזרקה שזה כבר הופך את זה לא רק
לSyntax 
חדש אלא ממש לתוספת לוגיקה לשפה.

אז כל ההקדמה הזאת זה כדי לתאר מה הוביל אותי לממש את התוספת הזאת. אומר מראש שאני לא מבין כל כך
בcompilerים
וכיצד כותבים שפות תכנות, היה פה הרבה ניסוי וטעייה.
בכל זאת אנסה לכתוב חלק ממה שלמדתי בדרך.

## CPython
הפרויקט שאעבוד עליו הוא המימוש המוכר של פייתון,
[CPython](https://github.com/python/cpython)
שכתוב
בC.

כדי לקמפל את בינארי שניתן לעבוד איתו עקבתי אחרי
[devguide](https://devguide.python.org/).
כדי להוסיף את
הSyntax
שרציתי אז התחלתי לחפש איך כל מיני דברים כמו
`if`, `try-except`, `while`
ממומשים.
כאשר צריך לזכור שפייתון היא שפה שהיא
interpeted,
כמעט לגמרי.
כלומר הקוד שאני כותב "מקומפל" לשפה שנקראית
Bytecode
שאותה
הInterpeter
של פייתון מריץ.
למה זה חשוב לזכור את זה, כי מה שאני מחפש זה לא איזור קוד שבוא אוכל להכניס לוגיקה של תנאי ואם התנאי מתקיים לקרוא 
ל`except`
בצורה רגילה ואחרת לא.
אלא אני מחפש כיצד אני יכול להוסיף גם את החוקיות של
הSyntax
החדש וגם כיצד לקמפל
Bytecode
של תנאי לכניסה
ל`except`.

### Grammer
נתחיל מהקובץ
`Grammar/python.gram`
אשר מכיל את החוקיות של
הSyntax של פייתון,
[**P**arsing **E**xpression **G**rammar](https://en.wikipedia.org/wiki/Parsing_expression_grammar).
החוקיות של הדקדוק נכנסה
ב[PEP 617](https://peps.python.org/pep-0617/)
ולמעשה יש כלי אוטומטי שיודע לעבור על הקובץ חוקים ולייצר ממנו קוד שמפרסר את השפה.
נבצע הוספה של
ה`if`
שלנו לחוקיות של
`except`. אפרק את התוספת לכמה חלקים שיהיה לי קל להסביר,

#### הוספת החוקיות

```diff
 except_block[excepthandler_ty]:
     | invalid_except_stmt_indent
-    | 'except' e=expression t=['as' z=NAME { z }] ':' b=block {
+    | 'except' e=expression t=['as' z=NAME { z }] c=['if' y=named_expression { y }]  ':' b=block {
```
בשינוי זה אני מאפשר אופצינלית
(בגלל זה סוגריים מרובעים)
להוסיף
`if`
אחרי
ה`except`,
ניתן לראות שזה למעשה מאד דומה לאפשרות להוסיף
`as`
אחרי
ה`except`.
לתנאי אני קורא `c`.
התוספת הבאה שצריך זה להחליט מה עושים עם התנאי הזה,

```diff
 except_block[excepthandler_ty]:
     | invalid_except_stmt_indent
     | 'except' e=expression t=['as' z=NAME { z }] c=['if' y=named_expression { y }]  ':' b=block {
-        _PyAST_ExceptHandler(e, (t) ? ((expr_ty) t)->v.Name.id : NULL, b, EXTRA) }
+        _PyAST_ExceptHandler(e, (t) ? ((expr_ty) t)->v.Name.id : NULL, b, c, EXTRA) }
```
הכתיבה הזאת למעשה מתארת כיצד לפרסר את החוקיות ולהכניס כל חלק בה כארגומנט לפונקציה שתתרגם אותה
לAST. 
התוספת כאן היא עוד ארגומנט לפונקציה אשר מכיל את התנאי.
(לכל קריאה לפונקציה בחוקיות שבה אין את התוספת Syntax שלי צריך להוסיף ארגומנט שהוא NULL. לא מראה את זה פה אבל ניתן לראות איך זה נראה בתוצאה הסופית של כל השינויים.)

לאחר התוספות הללו ניתן להריץ
```bash
make regen-pegen
```
ולראות שהיו שינויים בקובץ `Parser/parser.c` שאחראי על הפרסור של הקוד פייתון.



